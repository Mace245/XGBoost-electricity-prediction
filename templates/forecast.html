{% extends 'layout.html' %}

{% block title %}Energy Forecast (DMS){% endblock %}

{% block content %}
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h2>Energy Forecast (DMS)</h2>
        <div>
            <form action="{{ url_for('trigger_manual_retrain_route') }}" method="POST" style="display:inline-block;">
                <button type="submit" class="btn btn-warning btn-sm">Trigger Manual Retrain</button>
            </form>
            <!-- Removed Inject Data button -->
        </div>
    </div>

    <div class="shadow-sm p-3 mb-3 bg-light rounded">
        <h5>Latest Recorded Data:</h5>
        {% if latest_reading %}
        <p class="mb-0">
            <strong>Time ({{ latest_reading.timestamp_display.split(' ')[-1] if latest_reading.timestamp_display else 'Local' }}):</strong> {{ latest_reading.timestamp_display.rsplit(' ', 1)[0] if latest_reading.timestamp_display else 'N/A' }} <br>
            <strong>Energy (Wh):</strong> {{ latest_reading.EnergyWh if latest_reading.EnergyWh is not none else 'N/A' }} <br>
            <strong>Temperature (Â°C):</strong> {{ latest_reading.TemperatureCelsius if latest_reading.TemperatureCelsius is not none else 'N/A' }}
        </p>
        {% else %}
        <p class="text-muted mb-0">No historical data recorded yet.</p>
        {% endif %}
    </div>

    <p>Select forecast timeframe (Max available: {{ max_forecast_hours }} hours):</p>
    <div class="btn-group mb-3" role="group" aria-label="Forecast timeframe">
      <button type="button" class="btn btn-outline-primary timeframe-btn" data-timeframe="24h">1 Day (24h)</button>
      <button type="button" class="btn btn-outline-primary timeframe-btn" data-timeframe="72h">3 Days (72h)</button>
      <button type="button" class="btn btn-outline-primary timeframe-btn" data-timeframe="168h">1 Week (168h)</button>
      {% if max_forecast_hours and max_forecast_hours > 168 and max_forecast_hours % 24 == 0 %}
      <button type="button" class="btn btn-outline-primary timeframe-btn" data-timeframe="{{ max_forecast_hours }}h">{{ max_forecast_hours // 24 }} Days ({{max_forecast_hours}}h)</button>
      {% elif max_forecast_hours and max_forecast_hours > 168 %}
       <button type="button" class="btn btn-outline-primary timeframe-btn" data-timeframe="{{ max_forecast_hours }}h">Max ({{max_forecast_hours}}h)</button>
      {% endif %}
    </div>
    <button id="run-forecast" class="btn btn-success mb-3" disabled>Run Forecast</button>
    <span id="loading-indicator" style="display: none;"> <div class="spinner-border spinner-border-sm text-primary" role="status"></div> Loading forecast...</span>
    <div id="forecast-error-message" class="alert alert-danger mt-2" style="display: none;" role="alert"></div>

    <div style="height: 400px;">
        <canvas id="forecastChart"></canvas>
    </div>
{% endblock %}

{% block scripts %}
<script>
    // JavaScript for forecast.html remains largely the same as your last version.
    // Key things:
    // - Ensure `fetch("{{ url_for('run_forecast_dms_api') }}", ...)` is used.
    // - The `selectedTimeframeValue` from `data-timeframe` (e.g., "24h") is sent in the JSON body.
    // - Chart rendering logic handles the labels and data from the API response.
    // (Using the JS from your last forecast.html as a base)

    let selectedTimeframeValue = null;
    const timeframeButtons = document.querySelectorAll('.timeframe-btn');
    const runButton = document.getElementById('run-forecast');
    const loadingIndicator = document.getElementById('loading-indicator');
    const forecastErrorMessageDiv = document.getElementById('forecast-error-message');
    const ctxForecast = document.getElementById('forecastChart').getContext('2d');
    let forecastChartInstance = null;

    function renderForecastChart(chartData) {
        // ... (same renderForecastChart JS as in your previous forecast.html) ...
        // ... ensure it handles chartData.labels and chartData.data ...
        // ... and sets chart title appropriately ...
        forecastErrorMessageDiv.style.display = 'none';
        if (!chartData || !chartData.labels || chartData.labels.length === 0) {
            forecastErrorMessageDiv.textContent = 'No forecast data received or data is empty.';
            forecastErrorMessageDiv.style.display = 'block';
            if (forecastChartInstance) {
                forecastChartInstance.data.labels = [];
                forecastChartInstance.data.datasets[0].data = [];
                forecastChartInstance.update();
            }
            return;
        }

        if (forecastChartInstance) {
            forecastChartInstance.data.labels = chartData.labels;
            forecastChartInstance.data.datasets[0].data = chartData.data;
            forecastChartInstance.options.plugins.title.text = `Forecasted Energy (${selectedTimeframeValue})`;
            forecastChartInstance.update();
        } else {
            forecastChartInstance = new Chart(ctxForecast, {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        label: 'Forecasted Energy (Wh)',
                        data: chartData.data,
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        tension: 0.1,
                        fill: true
                    }]
                },
                options: {
                    scales: {
                        y: { beginAtZero: false, title: { display: true, text: 'Energy (Wh)' } },
                        x: { title: { display: true, text: 'Time (Local)' } } // Assuming labels from API are local
                    },
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: `Forecasted Energy (${selectedTimeframeValue})` },
                        tooltip: { callbacks: { title: function(tooltipItems) { return tooltipItems[0].label; } } }
                    }
                }
            });
        }
    }


    timeframeButtons.forEach(button => {
        button.addEventListener('click', () => {
            timeframeButtons.forEach(btn => btn.classList.remove('active', 'btn-primary'));
            timeframeButtons.forEach(btn => btn.classList.add('btn-outline-primary'));
            button.classList.add('active', 'btn-primary');
            button.classList.remove('btn-outline-primary');
            selectedTimeframeValue = button.getAttribute('data-timeframe');
            runButton.disabled = false;
        });
    });

    runButton.addEventListener('click', () => {
        if (!selectedTimeframeValue) { alert('Please select a timeframe.'); return; }
        runButton.disabled = true;
        loadingIndicator.style.display = 'inline-block';
        forecastErrorMessageDiv.style.display = 'none';

        fetch("{{ url_for('run_forecast_dms_api') }}", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ timeframe: selectedTimeframeValue }),
        })
        .then(response => {
            if (!response.ok) { return response.json().then(err => { throw new Error(err.error || `HTTP error ${response.status}`) }); }
            return response.json();
        })
        .then(data => {
            if (data.error) {
                forecastErrorMessageDiv.textContent = "Error: " + data.error;
                forecastErrorMessageDiv.style.display = 'block';
                renderForecastChart({ labels: [], data: [] });
            } else {
                renderForecastChart(data);
            }
        })
        .catch(error => {
            forecastErrorMessageDiv.textContent = 'Fetch error: ' + error.message;
            forecastErrorMessageDiv.style.display = 'block';
            renderForecastChart({ labels: [], data: [] });
        })
        .finally(() => {
            if (selectedTimeframeValue) runButton.disabled = false;
            loadingIndicator.style.display = 'none';
        });
    });
    renderForecastChart({ labels: [], data: [] }); // Initial empty chart
</script>
{% endblock %}